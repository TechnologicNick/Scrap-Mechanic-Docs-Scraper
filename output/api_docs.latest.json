{
	"author": "TechnologicNick",
	"version": "unspecified",
	"comment": "This json file was generated using an API docs scraper",
	"time": 1616707473164,
	"urls": {
		"discord": "https://discordapp.com/users/254340017575559178",
		"steam": "https://steamcommunity.com/id/TechnologicNick/",
		"github": "https://github.com/TechnologicNick"
	},
	"content": {
		"sm": {
			"constants": {},
			"tabledata": {
				"version": {
					"args": 0,
					"sandbox": "",
					"description": "`read-only` _string_ – The current version of the game: `0.3.3`.",
					"params": [],
					"returns": []
				},
				"isHost": {
					"args": 0,
					"sandbox": "",
					"description": "Returns whether the game is currently running on the [hosting](index.html#server) player's computer.\n\n`read-only` _bool_ – Whether the game is running on the host.",
					"params": [],
					"returns": []
				},
				"isServerMode": {
					"args": 0,
					"sandbox": "",
					"description": "Returns whether the script is currently running in [server mode](index.html#server). Otherwise, it is running in [client mode](index.html#client). Server mode only occurs when [`sm.isHost`]([[sm.ishost]] \"sm.ishost\") is true.",
					"params": [],
					"returns": [
						{
							"type": "bool",
							"description": "Whether the script is running in server mode."
						}
					]
				},
				"exists": {
					"args": 1,
					"sandbox": "",
					"description": "Returns whether an object exists in the game. This is useful for checking whether a reference to a [`shape`]([[userdata.shape]] \"userdata.shape\") or [`character`]([[userdata.character]] \"userdata.character\") is valid.",
					"params": [
						{
							"name": "object",
							"type": "any",
							"description": "The object instance."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Whether the object exists."
						}
					]
				}
			},
			"userdata": {}
		},
		"": {
			"constants": {},
			"tabledata": {
				"dofile": {
					"args": 1,
					"sandbox": "",
					"description": "Opens the named file and executes its contents as a Lua chunk. In case of errors, dofile propagates the error to its caller.",
					"params": [
						{
							"name": "filename",
							"type": "string",
							"description": "The name of the file to be loaded."
						}
					],
					"returns": []
				},
				"class": {
					"args": 1,
					"sandbox": "",
					"description": "Creates a new class object.",
					"params": [
						{
							"name": "base",
							"type": "string",
							"description": "An optional base class to inherit from."
						}
					],
					"returns": []
				},
				"print": {
					"args": 1,
					"sandbox": "",
					"description": "Prints data to the [console](index.html#console). This is useful for debugging.\n\nNote\n\nIf the game is running with the `-dev` flag, any output will be added to the game logs.",
					"params": [
						{}
					],
					"returns": []
				},
				"type": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the type of an object as a string. This includes standard Lua types and userdata types specific to this API.",
					"params": [
						{
							"name": "object",
							"type": "any",
							"description": "The object instance."
						}
					],
					"returns": [
						{
							"type": "string",
							"description": "The object type."
						}
					]
				}
			},
			"userdata": {}
		},
		"GenericClass": {
			"constants": {},
			"tabledata": {
				"client_onCreate": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when the scripted object is created. This occurs when a new object is built, spawned, or when the world is loaded.",
					"params": [],
					"returns": []
				},
				"client_onSetupGui": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when the scripted object is created or the resolution has changed.",
					"params": [],
					"returns": []
				},
				"client_onDestroy": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when the scripted object is destroyed.",
					"params": [],
					"returns": []
				},
				"client_onRefresh": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called if the Lua script attached to the object is modified while the game is running.\n\nNote\n\nThis event requires Scrap Mechanic to be running with the `-dev` flag. This will allow for scripts to automatically refresh upon changes.",
					"params": [],
					"returns": []
				},
				"client_onFixedUpdate": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called every game tick – 40 ticks a second. If the frame rate is lower than 40 fps, this event may be called twice.\n\nDuring a fixed update, physics and logic between interactables are updated.",
					"params": [],
					"returns": []
				},
				"client_onUpdate": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called every frame.\n\nDuring a frame update, graphics, animations and effects are updated.\n\nWarning\n\nBecause of how frequent this event is called, the game's frame rate is greatly affected by the amount of code executed here.\n\nFor any non-graphics related code, consider using [`GenericClass.client_onFixedUpdate`]([[genericclass.client_onfixedupdate]] \"genericclass.client_onfixedupdate\") instead. If the event is not in use, consider removing it from the script.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"ShapeClass": {
			"constants": {},
			"tabledata": {
				"maxChildCount": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the maximum number of allowed child connections – the number of outgoing connections.\n\n_int_ – The max child count. (Defaults to 0, no allowed child connections)",
					"params": [],
					"returns": []
				},
				"maxParentCount": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the maximum number of allowed parent connections – the number of incoming connections.\n\n_int_ – The max parent count. (Defaults to 0, no allowed parent connections)",
					"params": [],
					"returns": []
				},
				"connectionInput": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the connection input type. (See [`sm.interactable.connectionType`]([[sm.interactable.connectiontype]] \"sm.interactable.connectiontype\"))\n\n_int_ – The connection input. (Defaults to 0, no allowed input)",
					"params": [],
					"returns": []
				},
				"connectionOutput": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the connection output type. (See [`sm.interactable.connectionType`]([[sm.interactable.connectiontype]] \"sm.interactable.connectiontype\"))\n\n_int_ – The connection output. (Defaults to 0, no allowed output)",
					"params": [],
					"returns": []
				},
				"colorNormal": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the connection-point normal color. The point is shown when using the _Connect Tool_.\n\n_[`color`]([[userdata.color]] \"userdata.color\")_ – The normal color. (Defaults to white)",
					"params": [],
					"returns": []
				},
				"colorHighlight": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the connection-point highlight color. The point is shown when using the _Connect Tool_ and selecting the interactable.\n\n_[`color`]([[userdata.color]] \"userdata.color\")_ – The highlight color. (Defaults to white)",
					"params": [],
					"returns": []
				},
				"poseWeightCount": {
					"args": 0,
					"sandbox": "",
					"description": "Sets the number of poses the shape's model is able to use. This is mainly used for shape animations.\n\n_int_ – The pose weight count. (Defaults to 0)",
					"params": [],
					"returns": []
				},
				"client_onInteract": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when a player interacts with the shape by pressing `E`, or `0–9` if the shape is connected to a seat.\n\nNote\n\nIf this method is defined, a player will see the interaction text **\"Press E to use\"** when looking at the shape.\n\n\\-- Example of interaction\nfunction MySwitch.client\\_onInteract( self ) \n    self.network:sendToServer( 'server\\_toggle' )\nend\n\nfunction MySwitch.server\\_toggle( self ) \n    \\-- Toggle on and off\n    self.interactable.active \\= not self.interactable.active\nend",
					"params": [],
					"returns": []
				},
				"server_onProjectile": {
					"args": 0,
					"sandbox": "serverEvent",
					"description": "This event is called when the shape is hit by a [`projectile`]([[sm.projectile]] \"sm.projectile\").",
					"params": [],
					"returns": []
				},
				"server_onSledgehammer": {
					"args": 0,
					"sandbox": "serverEvent",
					"description": "This event is called when the shape is hit by a sledgehammer.",
					"params": [],
					"returns": []
				},
				"server_onExplosion": {
					"args": 0,
					"sandbox": "serverEvent",
					"description": "This event is called when the shape is within the destruction radius of a nearby explosion.\n\nFor more information about explosions, see [`sm.physics.explode()`]([[sm.physics.explode]] \"sm.physics.explode\").",
					"params": [],
					"returns": []
				},
				"server_onCollision": {
					"args": 0,
					"sandbox": "serverEvent",
					"description": "This event is called when the shape collides with another object. Currently, this is only used to detect collisions between shapes.",
					"params": [],
					"returns": []
				},
				"client_canInteract": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called to check whether the shape can be interacted upon. Return true if the shape can be interacted upon or false to prevent interaction.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"ToolClass": {
			"constants": {},
			"tabledata": {
				"client_onEquip": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when a player equips the tool.",
					"params": [],
					"returns": []
				},
				"client_onUnequip": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when a player unequips the tool.",
					"params": [],
					"returns": []
				},
				"client_onPrimaryUse": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when a player uses the tool with the primary (left) mouse button.\n\nThe interact [`state`]([[sm.tool.interactstate]] \"sm.tool.interactstate\") describes whether the mouse button is pressed, held or released.",
					"params": [],
					"returns": []
				},
				"client_onSecondaryUse": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when a player uses the tool with the secondary (right) mouse button.\n\nThe interact [`state`]([[sm.tool.interactstate]] \"sm.tool.interactstate\") describes whether the mouse button is pressed, held or released.",
					"params": [],
					"returns": []
				},
				"client_onToggle": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when the player presses `Q`.",
					"params": [],
					"returns": []
				},
				"client_onReload": {
					"args": 0,
					"sandbox": "clientEvent",
					"description": "This event is called when the player presses `R`.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.shape": {
			"constants": {},
			"tabledata": {
				"getId": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the id of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The shape's id."
						}
					]
				},
				"getShapeUuid": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the uuid string unique to a shape/block type.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "uuid",
							"description": "The shape's uuid."
						}
					]
				},
				"getColor": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the color of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "color",
							"description": "The shape's color."
						}
					]
				},
				"setColor": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Sets the color of a shape. This is similar to coloring with the _Paint Tool_.",
					"params": [
						{
							"name": "shape",
							"type": "body",
							"description": "The shape."
						},
						{
							"name": "color",
							"type": "color",
							"description": "The color."
						}
					],
					"returns": []
				},
				"getMass": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the mass of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The shape's mass."
						}
					]
				},
				"getMaterial": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the material of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "string",
							"description": "The shape's material."
						}
					]
				},
				"getWorldPosition": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the world position of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's world position."
						}
					]
				},
				"getLocalPosition": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the local grid postition of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's local position."
						}
					]
				},
				"getVelocity": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the linear velocity of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's linear velocity."
						}
					]
				},
				"getXAxis": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the local x-axis vector of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's x-axis."
						}
					]
				},
				"getYAxis": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the local y-axis vector of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's y-axis."
						}
					]
				},
				"getZAxis": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the local z-axis vector of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's z-axis."
						}
					]
				},
				"getAt": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the direction of a shape's front side.\n\nThe direction is affected by the shape's rotation in the world.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's at-axis."
						}
					]
				},
				"getRight": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the direction of a shape's right side.\n\nThe direction is affected by the shape's rotation in the world.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's right-axis."
						}
					]
				},
				"getUp": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the direction of a shape's top side.\n\nThe direction is affected by the shape's rotation in the world.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The shape's up-axis."
						}
					]
				},
				"transformPoint": {
					"args": 2,
					"sandbox": "",
					"description": "Transform a [`vec3`]([[userdata.vec3]] \"userdata.vec3\") with the local shape transform.\n\nlocal localPos \\= self.shape:transformPoint( worldPos )",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						},
						{
							"name": "vector",
							"type": "vec3",
							"description": "The untransformed vector."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The transformed vector."
						}
					]
				},
				"transformRotation": {
					"args": 2,
					"sandbox": "",
					"description": "Transform a [`quat`]([[userdata.quat]] \"userdata.quat\") with the local shape transform.\n\nlocal worldUp \\= sm.vec3.new( 0, 0, 1 )\nlocal worldRot \\= sm.vec3.getRotation( worldUp, worldDir )\nlocal localRot \\= self.shape:transformRotation( worldRot )",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						},
						{
							"name": "quat",
							"type": "quat",
							"description": "The untransformed quaternion."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "The transformed quaternion."
						}
					]
				},
				"getBoundingBox": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the bounding box of a shape – the dimensions that a shape occupies when building.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The size of the shape's bounding box."
						}
					]
				},
				"getBody": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the [`body`]([[userdata.body]] \"userdata.body\") a shape is part of.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "body",
							"description": "The body which the shape is part of."
						}
					]
				},
				"getInteractable": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the [`interactable`]([[userdata.interactable]] \"userdata.interactable\") of a shape, if one exists. Otherwise the function will return nil.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "interactable",
							"description": "The interactable belonging to the shape."
						}
					]
				},
				"destroyPart": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Destroy a part",
					"params": [
						{
							"name": "cs",
							"type": "shape",
							"description": "The part."
						},
						{
							"name": "attackLevel",
							"type": "int",
							"description": "Determines which quality level of parts the attack can destroy. Setting it to 0 (default) will destroy any part."
						}
					],
					"returns": []
				},
				"getWorldRotation": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the world rotation of a shape.",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "The shape's world rotation."
						}
					]
				},
				"createPart": {
					"args": 5,
					"sandbox": "serverMethod",
					"description": "Create a new part",
					"params": [
						{
							"name": "uuid",
							"type": "uuid",
							"description": "The uuid of the shape."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The shape's world position."
						},
						{
							"name": "rotation",
							"type": "quat",
							"description": "The shape's world rotation."
						},
						{
							"name": "dynamic",
							"type": "bool",
							"description": "Set true if the shape is dynamic or false if the shape is static."
						},
						{
							"name": "forceSpawn",
							"type": "bool",
							"description": "Set true to force spawn the shape even if it will cause collision."
						}
					],
					"returns": []
				},
				"createBlock": {
					"args": 6,
					"sandbox": "serverMethod",
					"description": "Create a new block",
					"params": [
						{
							"name": "uuid",
							"type": "uuid",
							"description": "The uuid of the shape."
						},
						{
							"name": "size",
							"type": "vec3",
							"description": "The size of the block."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The shape's world position."
						},
						{
							"name": "rotation",
							"type": "quat",
							"description": "The shape's world rotation."
						},
						{
							"name": "dynamic",
							"type": "bool",
							"description": "Set true if the shape is dynamic or false if the shape is static."
						},
						{
							"name": "forceSpawn",
							"type": "bool",
							"description": "Set true to force spawn the shape even if it will cause collision."
						}
					],
					"returns": []
				},
				"createJoint": {
					"args": 4,
					"sandbox": "serverMethod",
					"description": "Create a new joint",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The host shape."
						},
						{
							"name": "uuid",
							"type": "uuid",
							"description": "The uuid of the joint."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The joint's grid position."
						},
						{
							"name": "direction",
							"type": "vec3",
							"description": "The joint's normal direction."
						}
					],
					"returns": []
				},
				"destroyShape": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Destroy a shape",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						},
						{
							"name": "attackLevel",
							"type": "int",
							"description": "Determines which quality level of shape the attack can destroy. Setting it to 0 (default) will destroy any shape."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.body": {
			"constants": {},
			"tabledata": {
				"getId": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the id of a body.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The body's id."
						}
					]
				},
				"getMass": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the mass of a body.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The body's mass."
						}
					]
				},
				"getWorldPosition": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the world position of a body.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The body's world position."
						}
					]
				},
				"getVelocity": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the linear velocity of a body.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The body's linear velocity."
						}
					]
				},
				"getAngularVelocity": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the angular velocity of a body.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The body's angular velocity."
						}
					]
				},
				"getShapes": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of all [`shapes`]([[userdata.shape]] \"userdata.shape\") that are part of a body.\n\nThis will **not** return shapes in neighbouring bodies connected by [`joints`]([[userdata.joint]] \"userdata.joint\"), etc.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{}
					]
				},
				"getCreationShapes": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of all [`shapes`]([[userdata.shape]] \"userdata.shape\") that are part of a creation.\n\nA creation includes all bodies connected by [`joints`]([[userdata.joint]] \"userdata.joint\"), etc.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{}
					]
				},
				"getCreationBodies": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of all bodies in a creation.\n\nA creation includes all bodies connected by [`joints`]([[userdata.joint]] \"userdata.joint\"), etc.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{}
					]
				},
				"getCreationsFromBodies": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of tables, which is an array of tables containing bodies grouped by creation.\n\nA creation includes all bodies connected by [`joints`]([[userdata.joint]] \"userdata.joint\"), etc.",
					"params": [
						{}
					],
					"returns": [
						{}
					]
				},
				"hasChanged": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Returns true if the given tick is lower than the tick the body was last changed.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "tick",
							"type": "unsigned",
							"description": "The tick."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Returns true if the body has been changed."
						}
					]
				},
				"getAllBodies": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Returns a table with all the bodies in the world.",
					"params": [],
					"returns": [
						{}
					]
				},
				"isDynamic": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is dyanmic",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is dynamic."
						}
					]
				},
				"isStatic": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is static",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is static."
						}
					]
				},
				"isDestructable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is destructable.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is destructable."
						}
					]
				},
				"setDestructable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is destructable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is destructable."
						}
					],
					"returns": []
				},
				"isBuildable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is buildable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is buildable."
						}
					]
				},
				"setBuildable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is buildable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is buildable."
						}
					],
					"returns": []
				},
				"isPaintable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is paintable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is paintable."
						}
					]
				},
				"setPaintable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is non paintable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is paintable."
						}
					],
					"returns": []
				},
				"isConnectable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is connectable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is connectable."
						}
					]
				},
				"setConnectable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is connectable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is connectable."
						}
					],
					"returns": []
				},
				"isLiftable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is liftable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is liftable."
						}
					]
				},
				"setLiftable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is liftable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is liftable."
						}
					],
					"returns": []
				},
				"isUsable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is interactable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is interactable."
						}
					]
				},
				"setUsable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is liftable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is interactable."
						}
					],
					"returns": []
				},
				"isErasable": {
					"args": 1,
					"sandbox": "",
					"description": "Check if a body is erasable.",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the body is erasable."
						}
					]
				},
				"setErasable": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Controls whether a body is erasable",
					"params": [
						{
							"name": "body",
							"type": "body",
							"description": "The body."
						},
						{
							"name": "value",
							"type": "bool",
							"description": "Whether the body is erasable."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.interactable": {
			"constants": {},
			"tabledata": {
				"getId": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the id of an interactable.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The interactable's id."
						}
					]
				},
				"getType": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the interactable type of an interactable.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "string",
							"description": "The interactable's type. (sm.interactable.types)"
						}
					]
				},
				"getColorNormal": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the connection-point color of an interactable. The point is shown when using the _Connect Tool_.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "color",
							"description": "The connection-point color."
						}
					]
				},
				"getColorHighlight": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the connection-point highlight color of an interactable. The point is shown when using the _Connect Tool_.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "color",
							"description": "The connection-point highlight color."
						}
					]
				},
				"getMaxParentCount": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the maximum number of allowed parent connections of an interactable – the number of incoming connections.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The max parent connection count."
						}
					]
				},
				"getMaxChildCount": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the maximum number of allowed child connections of an interactable – the number of outgoing connections.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The max child connection count."
						}
					]
				},
				"isActive": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the logic output signal of an interactable. Signal is a boolean, **on** or **off**.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "The logic output signal."
						}
					]
				},
				"setActive": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Sets the logic output signal of an interactable. Signal is a boolean, **on** or **off**.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "signal",
							"type": "bool",
							"description": "The logic output signal."
						}
					],
					"returns": []
				},
				"getPower": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the power output signal of an interactable. Signal is a number between -1 to 1, where 1 is forward and -1 backward.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The power output signal."
						}
					]
				},
				"setPower": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Sets the power output signal of an interactable. Signal is a number between -1 to 1, where 1 is forward and -1 backward.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "signal",
							"type": "number",
							"description": "The power output signal."
						}
					],
					"returns": []
				},
				"getShape": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the [`shape`]([[userdata.shape]] \"userdata.shape\") of an interactable.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "shape",
							"description": "The shape which hosts the interactable."
						}
					]
				},
				"getBody": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the [`body`]([[userdata.body]] \"userdata.body\") an interactable's [`shape`]([[userdata.shape]] \"userdata.shape\") is part of.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "body",
							"description": "The body an interactable's shape is part of."
						}
					]
				},
				"getSingleParent": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the parent [`interactable`]([[userdata.interactable]] \"userdata.interactable\") that is connected to an interactable. The parent act as the interactable's input.\n\nWarning\n\nThis method is **not** allowed for an interactable that allows more than one parent connection. See [`sm.interactable.getMaxParentCount`]([[sm.interactable.getmaxparentcount]] \"sm.interactable.getmaxparentcount\").",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "interactable",
							"description": "The connected parent interactable."
						}
					]
				},
				"getParents": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of parent [`interactables`]([[userdata.interactable]] \"userdata.interactable\") that are connected to an interactable. The parents act as the interactable's input.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{}
					]
				},
				"getChildren": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of child [`interactables`]([[userdata.interactable]] \"userdata.interactable\") that an interactable is connected to. The children listen to the interactable's output.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{}
					]
				},
				"getJoints": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of all [`joints`]([[userdata.joint]] \"userdata.joint\") that an interactable is connected to. Joints include **bearings** and **pistons**.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{}
					]
				},
				"getBearings": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of [`bearings`]([[userdata.joint]] \"userdata.joint\") that an interactable is connected to.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{}
					]
				},
				"getPistons": {
					"args": 1,
					"sandbox": "",
					"description": "Returns a table of [`pistons`]([[userdata.joint]] \"userdata.joint\") that an interactable is connected to.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{}
					]
				},
				"getPoseWeight": {
					"args": 2,
					"sandbox": "clientMethod",
					"description": "Returns the pose weight of the pose in the given index.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "index",
							"type": "int",
							"description": "The index."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The pose weight."
						}
					]
				},
				"setPoseWeight": {
					"args": 3,
					"sandbox": "clientMethod",
					"description": "Set the pose weight of the pose in the given index.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "index",
							"type": "int",
							"description": "The index."
						},
						{
							"name": "value",
							"type": "number",
							"description": "The pose weight."
						}
					],
					"returns": []
				},
				"getUvFrameIndex": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Returns the index of the current UV animation frame",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The uv frame."
						}
					]
				},
				"setUvFrameIndex": {
					"args": 2,
					"sandbox": "clientMethod",
					"description": "Sets the UV animation frame with the given index.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "index",
							"type": "int",
							"description": "The index."
						}
					],
					"returns": []
				},
				"setAnimProgress": {
					"args": 3,
					"sandbox": "clientMethod",
					"description": "Sets the progress on the animation with the given name.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "name",
							"type": "string",
							"description": "The name of the animation."
						},
						{
							"name": "progress",
							"type": "number",
							"description": "The animation's progress between 0 and 1."
						}
					],
					"returns": []
				},
				"setAnimEnabled": {
					"args": 3,
					"sandbox": "clientMethod",
					"description": "Sets whether the animation with the given name should be applied to the mesh. True enables the animation and false disables it.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "name",
							"type": "string",
							"description": "The name of the animation."
						},
						{
							"name": "enabled",
							"type": "bool",
							"description": "The boolean enable state."
						}
					],
					"returns": []
				},
				"getLocalBonePosition": {
					"args": 2,
					"sandbox": "",
					"description": "Return the position of the bone",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "name",
							"type": "string",
							"description": "The bone name."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The position."
						}
					]
				},
				"getWorldBonePosition": {
					"args": 2,
					"sandbox": "",
					"description": "Return the position of the bone",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "name",
							"type": "string",
							"description": "The bone name."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The position."
						}
					]
				},
				"getContainer": {
					"args": 2,
					"sandbox": "",
					"description": "Returns the container stored in the given index inside the controller",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable."
						},
						{
							"name": "index",
							"type": "int",
							"description": "The index of the container (default: 0)."
						}
					],
					"returns": [
						{
							"type": "container",
							"description": "The container."
						}
					]
				},
				"types": {
					"args": 0,
					"sandbox": "",
					"description": "`read-only` _table_ – The type list.",
					"params": [],
					"returns": []
				},
				"connectionType": {
					"args": 0,
					"sandbox": "",
					"description": "### Logic[¶](#logic \"Permalink to this headline\")\n\nThe interactable sends or reads a boolean signal to signal it's current state. ([`isActive`]([[sm.interactable.isactive]] \"sm.interactable.isactive\")) to signal its output.\n\nIn: The interactable reads a boolean ([`isActive`]([[sm.interactable.isactive]] \"sm.interactable.isactive\")) from its parent as input.\n\n### Power[¶](#power \"Permalink to this headline\")\n\nOut: The controller uses a float ([`getPower`]([[sm.interactable.getpower]] \"sm.interactable.getpower\")) to signal strength output (steering only).\n\nIn: The controller reads a float ([`getPower`]([[sm.interactable.getpower]] \"sm.interactable.getpower\")) from its parent as input for strength.\n\n`read-only` _table_ – The connection type list.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.joint": {
			"constants": {},
			"tabledata": {
				"createPart": {
					"args": 6,
					"sandbox": "serverMethod",
					"description": "Create a part on joint",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The parent joint."
						},
						{
							"name": "uuid",
							"type": "uuid",
							"description": "The uuid of the shape."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The shape's local position."
						},
						{},
						{},
						{
							"name": "forceCreate",
							"type": "bool",
							"description": "Set true to force create the shape."
						}
					],
					"returns": []
				},
				"createBlock": {
					"args": 5,
					"sandbox": "serverMethod",
					"description": "Create a block on joint",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The parent joint."
						},
						{
							"name": "uuid",
							"type": "uuid",
							"description": "The uuid of the shape."
						},
						{
							"name": "size",
							"type": "vec3",
							"description": "The shape's size."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The shape's local position."
						},
						{
							"name": "forceCreate",
							"type": "bool",
							"description": "Set true to force create the shape."
						}
					],
					"returns": []
				},
				"getId": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the id of a joint.",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The joint."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The joint's id."
						}
					]
				},
				"getType": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the joint type of a joint.",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The joint."
						}
					],
					"returns": [
						{
							"type": "string",
							"description": "The joint's type. (sm.joint.types)"
						}
					]
				},
				"getShapeA": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the [`shape`]([[userdata.shape]] \"userdata.shape\") a joint is attached to. This shape does always exist.",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The joint."
						}
					],
					"returns": [
						{
							"type": "shape",
							"description": "The joint's first shape."
						}
					]
				},
				"getShapeB": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the [`shape`]([[userdata.shape]] \"userdata.shape\") that is attached to a joint on another [`body`]([[userdata.body]] \"userdata.body\"). This method returns nil if there is no shape attached to the joint.",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The joint."
						}
					],
					"returns": [
						{
							"type": "shape",
							"description": "The joint's second shape."
						}
					]
				},
				"getColor": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the color of a joint.",
					"params": [
						{
							"name": "joint",
							"type": "joint",
							"description": "The joint."
						}
					],
					"returns": [
						{
							"type": "color",
							"description": "The joint's color."
						}
					]
				},
				"getAngle": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the angle of a bearing.",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The bearing's angle. The angle ranges between -math.pi and +math.pi."
						}
					]
				},
				"getAngularVelocity": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the angular velocity of a bearing.\n\nThe angular velocity can be set using [`setMotorVelocity`]([[sm.joint.setmotorvelocity]] \"sm.joint.setmotorvelocity\") or [`setTargetAngle`]([[sm.joint.settargetangle]] \"sm.joint.settargetangle\").",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The bearing's angular velocity."
						}
					]
				},
				"getAppliedImpulse": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the applied impulse of a bearing.\n\nThe applied impulse can be set using [`setMotorVelocity`]([[sm.joint.setmotorvelocity]] \"sm.joint.setmotorvelocity\") or [`setTargetAngle`]([[sm.joint.settargetangle]] \"sm.joint.settargetangle\").",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The bearing's applied impulse."
						}
					]
				},
				"isReversed": {
					"args": 1,
					"sandbox": "",
					"description": "Returns whether a bearing has been reversed using the _Connect Tool_. A reversed bearing rotates counterclockwise.",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Whether the bearing is reversed (rotating counterclockwise)."
						}
					]
				},
				"setMotorVelocity": {
					"args": 3,
					"sandbox": "serverMethod",
					"description": "Sets the motor velocity for a bearing. The bearing will try to maintain the target velocity with the given amount of impulse/strength.\n\nIn Scrap Mechanic, the Gas Engine increases both velocity and impulse with every gear. The Electic Engine increases velocity, but maintains the same impulse for every gear, making it sturdier.\n\nThis method cancels the effects of [`setTargetAngle`]([[sm.joint.settargetangle]] \"sm.joint.settargetangle\").",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						},
						{
							"name": "targetVelocity",
							"type": "number",
							"description": "The target velocity."
						},
						{
							"name": "maxImpulse",
							"type": "number",
							"description": "The max impulse."
						}
					],
					"returns": []
				},
				"setTargetAngle": {
					"args": 4,
					"sandbox": "serverMethod",
					"description": "Sets the target angle for a bearing. The bearing will try to reach the target angle with the target velocity and the given amount of impulse/strength.\n\nThe target angle is set to range between `-math.pi` and `+math.pi`. The bearing will always try to rotate in the direction closest to the target angle.\n\nThis method cancels the effects of [`setMotorVelocity`]([[sm.joint.setmotorvelocity]] \"sm.joint.setmotorvelocity\").",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						},
						{
							"name": "targetAngle",
							"type": "number",
							"description": "The target angle."
						},
						{
							"name": "targetVelocity",
							"type": "number",
							"description": "The target velocity."
						},
						{
							"name": "maxImpulse",
							"type": "number",
							"description": "The max impulse."
						}
					],
					"returns": []
				},
				"getLength": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the current length of a piston. The length is measured in blocks.",
					"params": [
						{
							"name": "piston",
							"type": "joint",
							"description": "The piston."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The piston's current length in blocks."
						}
					]
				},
				"setTargetLength": {
					"args": 4,
					"sandbox": "serverMethod",
					"description": "Sets the target length for a piston. The piston will try to reach the target length with the target velocity and the given amount of impulse/strength.\n\nThe target length is measured in blocks.\n\nThis method cancels the effects of [`setMotorVelocity`]([[sm.joint.setmotorvelocity]] \"sm.joint.setmotorvelocity\").",
					"params": [
						{
							"name": "bearing",
							"type": "joint",
							"description": "The bearing."
						},
						{
							"name": "targetLength",
							"type": "number",
							"description": "The target length."
						},
						{
							"name": "targetVelocity",
							"type": "number",
							"description": "The target velocity."
						},
						{
							"name": "maxImpulse",
							"type": "number",
							"description": "The max impulse. (Defaults to impulse used in game)"
						}
					],
					"returns": []
				},
				"types": {
					"args": 0,
					"sandbox": "",
					"description": "`read-only` _table_ – The type list.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.player": {
			"constants": {},
			"tabledata": {
				"getAllPlayers": {
					"args": 0,
					"sandbox": "",
					"description": "Returns a table of all [`players`]([[userdata.player]] \"userdata.player\") that are currently in the game.",
					"params": [],
					"returns": [
						{}
					]
				},
				"placeLift": {
					"args": 5,
					"sandbox": "serverMethod",
					"description": "Place down a lift game object",
					"params": [
						{
							"name": "player",
							"type": "player",
							"description": "The player to own the lift."
						},
						{},
						{
							"name": "position",
							"type": "vec3",
							"description": "The lift position."
						},
						{
							"name": "level",
							"type": "int",
							"description": "The lift level."
						},
						{
							"name": "rotation",
							"type": "int",
							"description": "The rotation of the creation on the lift."
						}
					],
					"returns": []
				},
				"removeLift": {
					"args": 1,
					"sandbox": "serverMethod",
					"description": "Remove the player's lift, if the lift exists.",
					"params": [
						{
							"name": "player",
							"type": "player",
							"description": "The player that owns the lift."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.character": {
			"constants": {},
			"tabledata": {
				"createCharacter": {
					"args": 4,
					"sandbox": "serverMethod",
					"description": "Creates a new character in a world.",
					"params": [
						{
							"name": "player",
							"type": "player",
							"description": "The player controlling the character."
						},
						{
							"name": "world",
							"type": "world",
							"description": "The world the character is created in."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The world position of the character."
						},
						{
							"name": "character",
							"type": "character",
							"description": "The old character to inherit from (Optional)."
						}
					],
					"returns": [
						{
							"type": "character",
							"description": "The created character."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.tool": {
			"constants": {},
			"tabledata": {
				"checkLiftCollision": {
					"args": 3,
					"sandbox": "",
					"description": "Used to check collisions between the lift and the world.",
					"params": [
						{},
						{
							"name": "position",
							"type": "vec3",
							"description": "The lift position."
						},
						{
							"name": "rotation",
							"type": "int",
							"description": "The rotation of the creation on the lift."
						}
					],
					"returns": []
				},
				"preloadRenderables": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Pre-loads renderable data to be used by the tool. This eliminates excessive loading during run time.",
					"params": [
						{}
					],
					"returns": []
				},
				"interactState": {
					"args": 0,
					"sandbox": "",
					"description": "The interact state describe what kind of interaction is made. This is used to check whether a mouse button or key was just made pressed, held, etc.\n\nThe states are:\n\n*   **null** – No keypress was made.\n*   **start** – The key was just pressed.\n*   **hold** – The key is held down.\n*   **stop** – The key was just released.\n\n`read-only` _table_ – The interact state list.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.areaTrigger": {
			"constants": {},
			"tabledata": {
				"createBox": {
					"args": 4,
					"sandbox": "",
					"description": "Creates a new box area trigger at a given position with a given size.\n\nIf a filter is specified, the trigger area will only be able to detects objects of that certain type. See [`sm.areaTrigger.filter`]([[sm.areatrigger.filter]] \"sm.areatrigger.filter\") for more information about filters.",
					"params": [
						{
							"name": "dimension",
							"type": "vec3",
							"description": "The dimensions of the box."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The world position."
						},
						{
							"name": "rotation",
							"type": "quat",
							"description": "The world rotation."
						},
						{
							"name": "filter",
							"type": "int",
							"description": "The object types the area trigger may detect. (See sm.areaTrigger.filter)"
						}
					],
					"returns": [
						{
							"type": "areaTrigger",
							"description": "The created area trigger."
						}
					]
				},
				"createAttachedBox": {
					"args": 5,
					"sandbox": "",
					"description": "Creates an area trigger box with a given size that stays attached to an [`interactable`]([[sm.interactable]] \"sm.interactable\")\n\nIf a filter is specified, the trigger area will only be able to detects objects of that certain type. See [`sm.areaTrigger.filter`]([[sm.areatrigger.filter]] \"sm.areatrigger.filter\") for more information about filters.",
					"params": [
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The host interactable"
						},
						{
							"name": "dimension",
							"type": "vec3",
							"description": "The size of the box"
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The position offset"
						},
						{
							"name": "rotation",
							"type": "quat",
							"description": "The rotation offset"
						},
						{
							"name": "filter",
							"type": "int",
							"description": "The object types the area trigger may detect. (See sm.areaTrigger.filter)"
						}
					],
					"returns": [
						{
							"type": "areaTrigger",
							"description": "The created area trigger."
						}
					]
				},
				"destroy": {
					"args": 1,
					"sandbox": "",
					"description": "Destroys an area trigger.",
					"params": [
						{
							"name": "areaTrigger",
							"type": "areaTrigger",
							"description": "The area trigger to be destroyed."
						}
					],
					"returns": []
				},
				"filter": {
					"args": 0,
					"sandbox": "",
					"description": "Filters are used to specify what object types an area trigger is able to detect. If an area trigger is created with a filter, it will **only** react to objects of that type. Filters can be combined by adding them.\n\nThe filters are:\n\n*   **dynamicBody** – Detects [`bodies`]([[userdata.body]] \"userdata.body\") that are free to move around in the world.\n*   **staticBody** – Detects [`bodies`]([[userdata.body]] \"userdata.body\") that are built on the ground or on the lift.\n*   **character** – Detects [`characters`]([[userdata.character]] \"userdata.character\") such as players.\n*   **all** – Detects all of the object types above. (Default)\n\n`read-only` _table_ – The filter type list.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.container": {
			"constants": {},
			"tabledata": {
				"beginTransaction": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Starts a new _transaction_ shared across all containers. A transaction is a collection of all changes of container items will be collected and processed\n\nA transaction must be ended with [`sm.container.endTransaction`]([[sm.container.endtransaction]] \"sm.container.endtransaction\").",
					"params": [],
					"returns": [
						{
							"type": "bool",
							"description": "Whether starting a transaction was successful."
						}
					]
				},
				"endTransaction": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Ends a transaction.",
					"params": [],
					"returns": [
						{
							"type": "bool",
							"description": "Whether ending a transaction was successful."
						}
					]
				},
				"abortTransaction": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Aborts a transaction.",
					"params": [],
					"returns": []
				},
				"getSize": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the number of slots in a container.",
					"params": [
						{
							"name": "container",
							"type": "container",
							"description": "The container."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The size."
						}
					]
				},
				"setItem": {
					"args": 4,
					"sandbox": "serverMethod",
					"description": "Sets the number of items stacked in a given container slot.",
					"params": [
						{
							"name": "container",
							"type": "container",
							"description": "The container."
						},
						{
							"name": "slot",
							"type": "int",
							"description": "The slot."
						},
						{
							"name": "itemUuid",
							"type": "uuid",
							"description": "The uuid of the item."
						},
						{
							"name": "quantity",
							"type": "int",
							"description": "The number of items."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Indicates if the action is possible."
						}
					]
				},
				"getItem": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Returns a table containing item uuid, quantity (and instance id for tools) at given slot.",
					"params": [
						{
							"name": "container",
							"type": "container",
							"description": "The container."
						},
						{
							"name": "slot",
							"type": "int",
							"description": "The slot."
						}
					],
					"returns": [
						{}
					]
				},
				"hasChanged": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Returns true if the given tick is lower than the tick the container was last changed.",
					"params": [
						{
							"name": "container",
							"type": "container",
							"description": "The container."
						},
						{
							"name": "tick",
							"type": "unsigned",
							"description": "The tick."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Returns true if the container has been changed."
						}
					]
				},
				"isEmpty": {
					"args": 1,
					"sandbox": "serverMethod",
					"description": "Returns true if the container is empty.",
					"params": [
						{
							"name": "container",
							"type": "container",
							"description": "The container."
						}
					],
					"returns": [
						{
							"type": "bool",
							"description": "Returns true if the container is empty."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.physics": {
			"constants": {},
			"tabledata": {
				"raycast": {
					"args": 3,
					"sandbox": "",
					"description": "Performs a [ray cast](https://en.wikipedia.org/wiki/Ray_casting) between two positions.\n\nThe returned [`raycastResult`]([[userdata.raycastresult]] \"userdata.raycastresult\") contains information about any object intersected by the ray.\n\nIf the ray cast is called from within a shape (e.g. a Sensor), a [`body`]([[userdata.body]] \"userdata.body\") may be provided which the ray will not intersect.",
					"params": [
						{
							"name": "start",
							"type": "vec3",
							"description": "The start position."
						},
						{
							"name": "end",
							"type": "vec3",
							"description": "The end position."
						},
						{
							"name": "body",
							"type": "body",
							"description": "The body to be ignored. (Optional)"
						}
					],
					"returns": [
						{}
					]
				},
				"distanceRaycast": {
					"args": 2,
					"sandbox": "",
					"description": "Performs a distance [ray cast](https://en.wikipedia.org/wiki/Ray_casting) from a position with a given direction.\n\nNote\n\n[`sm.physics.distanceRaycast`]([[sm.physics.distanceraycast]] \"sm.physics.distanceraycast\") is generally cheaper to use than [`sm.physics.raycast`]([[sm.physics.raycast]] \"sm.physics.raycast\") as it performs collision checks in a simplified world. If the raycast is only used for checking collision, it is adviced to use this method instead.",
					"params": [
						{
							"name": "start",
							"type": "vec3",
							"description": "The start position."
						},
						{
							"name": "direction",
							"type": "vec3",
							"description": "The ray's direction and length."
						}
					],
					"returns": [
						{}
					]
				},
				"applyImpulse": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Applies an impulse to a [`character`]([[userdata.character]] \"userdata.character\"), changing its velocity immediately. The impulse is applied to the character's centerpoint.",
					"params": [
						{
							"name": "target",
							"type": "character",
							"description": "The character on which the impulse is exerted on."
						},
						{
							"name": "impulse",
							"type": "vec3",
							"description": "The direction and strength of the impulse."
						}
					],
					"returns": []
				},
				"applyTorque": {
					"args": 3,
					"sandbox": "serverMethod",
					"description": "Applies a torque impulse to a [`body`]([[userdata.body]] \"userdata.body\"), changing its angular velocity immediately. The torque is applied along the body's center of mass, making it rotate.",
					"params": [
						{
							"name": "target",
							"type": "body",
							"description": "The object on which the torque is exerted on."
						},
						{
							"name": "torque",
							"type": "vec3",
							"description": "The direction and strength of the torque."
						},
						{
							"name": "global",
							"type": "number",
							"description": "Whether the torque is applied in global coordinates. (Defaults to local rotation)"
						}
					],
					"returns": []
				},
				"explode": {
					"args": 7,
					"sandbox": "serverMethod",
					"description": "Creates an explosion at given position. The explosion creates a shockwave that is capable of destroying blocks and pushing characters and creations away.\n\nShapes that are within the explosion's destruction radius may receive the event [`server_onExplosion`]([[shapeclass.server_onexplosion]] \"shapeclass.server_onexplosion\").\n\nNote\n\nThe **destruction level** is the damage effect on blocks and parts, determining how likely it is that they are destroyed. This is related to the `qualityLevel` found in parts json-files.\n\nAny quality level equal to or less than the destruction level may be destroyed. The effect fades one level every half travelled of the remaining destruction radius.\n\nA quality level of 0 means a block or part is indestructible.",
					"params": [
						{
							"name": "position",
							"type": "vec3",
							"description": "The center point of the explosion."
						},
						{
							"name": "level",
							"type": "int",
							"description": "The destruction level affecting nearby objects."
						},
						{
							"name": "destructionRadius",
							"type": "number",
							"description": "The destruction radius. Objects inside this sphere may be destroyed."
						},
						{
							"name": "impulseRadius",
							"type": "number",
							"description": "The impulse radius. Objects inside this sphere are affected by an impulse."
						},
						{
							"name": "magnitude",
							"type": "number",
							"description": "The impulse strength of the explosion. The strength diminishes with distance."
						},
						{
							"name": "effectName",
							"type": "string",
							"description": "The name of the effect to be played upon explosion. (Optional)"
						},
						{
							"name": "ignoreShape",
							"type": "shape",
							"description": "The shape to be ignored. (Optional)"
						}
					],
					"returns": []
				},
				"setGravity": {
					"args": 1,
					"sandbox": "serverMethod",
					"description": "Sets the gravitational acceleration affecting [`shapes`]([[userdata.shape]] \"userdata.shape\") and [`bodies`]([[userdata.body]] \"userdata.body\").",
					"params": [
						{
							"name": "gravity",
							"type": "number",
							"description": "The gravitational value."
						}
					],
					"returns": []
				},
				"getGravity": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Returns the gravitational acceleration affecting [`shapes`]([[userdata.shape]] \"userdata.shape\") and [`bodies`]([[userdata.body]] \"userdata.body\").",
					"params": [],
					"returns": [
						{
							"type": "number",
							"description": "The gravitational value."
						}
					]
				},
				"types": {
					"args": 0,
					"sandbox": "",
					"description": "Physics types are used to define an object's characteristics is in the physics world. Upon a raycast or collision detection, these types are used to find out what object was intersected.\n\n`read-only` _table_ – The physics types list.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.storage": {
			"constants": {},
			"tabledata": {
				"save": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Saves any Lua data at a given channel. A _channel_ can be any integer, and acts as the location the data will be stored at.\n\nThe data will remain stored after closing the world, and is retrieved using [`load`]([[sm.storage.load]] \"sm.storage.load\"), provided the same channel number.\n\nNote\n\nThe data is stored globally **within the current mod**. As of such, channels will not collide with external mods and scripts.",
					"params": [
						{
							"name": "channel",
							"type": "int",
							"description": "The channel number."
						},
						{
							"name": "data",
							"type": "any",
							"description": "The data to be stored."
						}
					],
					"returns": []
				},
				"load": {
					"args": 1,
					"sandbox": "serverMethod",
					"description": "Loads Lua data stored at a given channel. A _channel_ can be any integer, and acts as the location the data is stored at.\n\nIf no data is stored at the given channel, this returns nil.",
					"params": [
						{
							"name": "channel",
							"type": "int",
							"description": "The channel number."
						}
					],
					"returns": [
						{
							"type": "any",
							"description": "The data stored."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.localPlayer": {
			"constants": {},
			"tabledata": {
				"getPlayer": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the player object of the local player.",
					"params": [],
					"returns": [
						{
							"type": "player",
							"description": "The player object."
						}
					]
				},
				"getId": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the unique player id of the local player.",
					"params": [],
					"returns": [
						{
							"type": "int",
							"description": "The player's id."
						}
					]
				},
				"getPosition": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the world postition of the local player.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The player's world position."
						}
					]
				},
				"getDirection": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the direction the local player is aiming.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The direction of the player's aim."
						}
					]
				},
				"getRight": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the right-vector perpendicular to the local player's aim.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The right-vector of the player's aim."
						}
					]
				},
				"getUp": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the up-vector perpendicular to the local player's aim.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The up-vector of the player's aim."
						}
					]
				},
				"getRaycastStart": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the start position of the local player's raycast. The position depends on the [`camera`]([[sm.camera]] \"sm.camera\")'s position, and whether it's in first- of third-person.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The start position of the raycast."
						}
					]
				},
				"getRaycast": {
					"args": 3,
					"sandbox": "clientMethod",
					"description": "Performs a [raycast](https://en.wikipedia.org/wiki/Ray_casting) relative to the local player's perspective.",
					"params": [
						{
							"name": "range",
							"type": "number",
							"description": "The maximum range."
						},
						{
							"name": "origin",
							"type": "vec3",
							"description": "The start position. (Defaults to getRaycastStart)"
						},
						{
							"name": "direction",
							"type": "vec3",
							"description": "The direction. (Defaults to getDirection)"
						}
					],
					"returns": [
						{}
					]
				}
			},
			"userdata": {}
		},
		"sm.camera": {
			"constants": {},
			"tabledata": {
				"getPosition": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the world postition of the camera.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The camera's world position."
						}
					]
				},
				"getDirection": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the direction the camera is aiming.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The direction of the camera's aim."
						}
					]
				},
				"getUp": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the up-vector perpendicular to the camera's aim.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The up-vector of the camera's aim."
						}
					]
				},
				"getRight": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the right-vector perpendicular to the camera's aim.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The right-vector of the camera's aim."
						}
					]
				},
				"getFov": {
					"args": 0,
					"sandbox": "clientMethod",
					"description": "Returns the camera's field of view angle.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The field of view."
						}
					]
				},
				"setShake": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Sets the camera's level of camera shake.",
					"params": [
						{
							"name": "strength",
							"type": "number",
							"description": "The camera shake strength."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.audio": {
			"constants": {},
			"tabledata": {
				"play": {
					"args": 2,
					"sandbox": "clientMethod",
					"description": "Plays a sound.\n\nIf position is specified, the sound will play at the given coordinates in the world. Otherwise, the sound will play normally.\n\nFor a list of available sounds to play, see [`sm.audio.soundList`]([[sm.audio.soundlist]] \"sm.audio.soundlist\").",
					"params": [
						{
							"name": "sound",
							"type": "string",
							"description": "The sound to play."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The world position of the sound. (Optional)"
						}
					],
					"returns": []
				},
				"soundList": {
					"args": 0,
					"sandbox": "",
					"description": "`read-only` _{string}_ – A table of available sounds in the game.",
					"params": [],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.particle": {
			"constants": {},
			"tabledata": {
				"createParticle": {
					"args": 4,
					"sandbox": "clientMethod",
					"description": "Create a particle effect at a given position and rotation.\n\nNote\n\nIf you start a looping particle effect through this method then the only way to get rid of it is by reloading the save.",
					"params": [
						{
							"name": "particle",
							"type": "string",
							"description": "The particle name."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The position."
						},
						{
							"name": "rotation",
							"type": "quat",
							"description": "The rotation. (Defaults to no rotation)"
						},
						{
							"name": "color",
							"type": "color",
							"description": "The blend color. (Defaults to white)"
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.effect": {
			"constants": {},
			"tabledata": {
				"playEffect": {
					"args": 4,
					"sandbox": "",
					"description": "Plays an effect. If this function is called on the server it will play the effect on all clients.\n\nNote\n\nIf you start a looping effect using this function you will not be able to stop it.  \nPlease use [`createEffect`]([[sm.effect.createeffect]] \"sm.effect.createeffect\") for looping effects",
					"params": [
						{
							"name": "name",
							"type": "string",
							"description": "The name."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The position."
						},
						{
							"name": "velocity",
							"type": "vec3",
							"description": "The velocity. (Defaults to no velocity)"
						},
						{
							"name": "rotation",
							"type": "quat",
							"description": "The rotation. (Defaults to no rotation)"
						}
					],
					"returns": []
				},
				"createEffect": {
					"args": 3,
					"sandbox": "clientMethod",
					"description": "Creates an effect.\n\nIf you provide a host interactable to the effect then it will fetch position, velocity and orientation data from the interactable instead of relying on this information being fed to it.\n\nThis results in far more accurate positioning of effects that are supposed to stay attached to an object.",
					"params": [
						{
							"name": "name",
							"type": "string",
							"description": "The name."
						},
						{
							"name": "interactable",
							"type": "interactable",
							"description": "The interactable the effect is attached to. (Optional)"
						},
						{
							"name": "name",
							"type": "string",
							"description": "The bone name. (Optional)"
						}
					],
					"returns": [
						{
							"type": "effect",
							"description": "The created effect."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.projectile": {
			"constants": {},
			"tabledata": {
				"getProjectileMass": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the mass of a projectile.",
					"params": [
						{
							"name": "name",
							"type": "string",
							"description": "The projectile's name."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The mass."
						}
					]
				},
				"playerFire": {
					"args": 6,
					"sandbox": "clientMethod",
					"description": "Creates and fires a projectile from a player.\n\nThe projectile is normally fired from the player's position, but due to the weapon being held off-center it may require a fake position for where the projectile appears to be fired from.",
					"params": [
						{
							"name": "name",
							"type": "string",
							"description": "The projectile's name."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The start position."
						},
						{
							"name": "velocity",
							"type": "vec3",
							"description": "The direction and velocity."
						},
						{
							"name": "fakePosThird",
							"type": "vec3",
							"description": "The visual start position in third-person. (Defaults to position)"
						},
						{
							"name": "fakePosFirst",
							"type": "vec3",
							"description": "The visual start position in first-person. (Defaults to position)"
						},
						{
							"name": "delay",
							"type": "int",
							"description": "The number of ticks before firing. (Defaults to 0)"
						}
					],
					"returns": []
				},
				"shapeFire": {
					"args": 5,
					"sandbox": "serverMethod",
					"description": "Creates and fires a projectile from a [`shape`]([[userdata.shape]] \"userdata.shape\").",
					"params": [
						{
							"name": "shape",
							"type": "shape",
							"description": "The shape."
						},
						{
							"name": "name",
							"type": "string",
							"description": "The projectile's name."
						},
						{
							"name": "position",
							"type": "vec3",
							"description": "The start position."
						},
						{
							"name": "velocity",
							"type": "vec3",
							"description": "The direction and velocity."
						},
						{
							"name": "delay",
							"type": "int",
							"description": "The number of ticks before firing. (Defaults to 0)"
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.event": {
			"constants": {},
			"tabledata": {
				"sendToGame": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Sends a event from a world script to the game script.",
					"params": [
						{
							"name": "callbackMethod",
							"type": "string",
							"description": "The function name in the game script."
						},
						{
							"name": "args",
							"type": "any",
							"description": "Optional arguments to be sent to the game script."
						}
					],
					"returns": []
				},
				"sendToWorld": {
					"args": 3,
					"sandbox": "serverMethod",
					"description": "Sends a event from the game script to a specified world script.",
					"params": [
						{
							"name": "world",
							"type": "world",
							"description": "The world."
						},
						{
							"name": "callbackMethod",
							"type": "string",
							"description": "The function name in a world script."
						},
						{
							"name": "args",
							"type": "any",
							"description": "Optional arguments to be sent to the world script."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.world": {
			"constants": {},
			"tabledata": {
				"createWorld": {
					"args": 4,
					"sandbox": "serverMethod",
					"description": "Creates a new world object. Can only be called from inside the Game script environment.",
					"params": [
						{
							"name": "filename",
							"type": "string",
							"description": "The world script filename."
						},
						{
							"name": "classname",
							"type": "string",
							"description": "The world script class name."
						},
						{
							"name": "terrainParams",
							"type": "string",
							"description": "The world's terrain parameters."
						},
						{
							"name": "seed",
							"type": "int",
							"description": "The world's seed."
						}
					],
					"returns": [
						{
							"type": "world",
							"description": "The created world object."
						}
					]
				},
				"destroyWorld": {
					"args": 1,
					"sandbox": "serverMethod",
					"description": "Destroys the given world. Can only be called from inside the Game script environment.",
					"params": [
						{
							"name": "world",
							"type": "world",
							"description": "The world that should be removed."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.game": {
			"constants": {},
			"tabledata": {
				"getCurrentTick": {
					"args": 0,
					"sandbox": "",
					"description": "Return the current game tick",
					"params": [],
					"returns": [
						{
							"type": "number",
							"description": "The tick."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.challenge": {
			"constants": {},
			"tabledata": {
				"start": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Starts challenge.",
					"params": [],
					"returns": []
				},
				"stop": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Stops challenge.",
					"params": [],
					"returns": []
				},
				"hasStarted": {
					"args": 0,
					"sandbox": "serverMethod",
					"description": "Check if a challenge has started",
					"params": [],
					"returns": [
						{
							"type": "bool",
							"description": "Return true if the challenge has started."
						}
					]
				},
				"levelCompleted": {
					"args": 2,
					"sandbox": "serverMethod",
					"description": "Completes a challenge level and saves progression.",
					"params": [
						{
							"name": "level",
							"type": "int",
							"description": "The level's index."
						},
						{
							"name": "time",
							"type": "number",
							"description": "The completion time."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.visualization": {
			"constants": {},
			"tabledata": {
				"setCreationBodies": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Sets an array of bodies to visualize.",
					"params": [
						{}
					],
					"returns": []
				},
				"setCreationVisible": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Controls the visibility of the creation visualization",
					"params": [
						{
							"name": "visible",
							"type": "bool",
							"description": "Wheter the creation visualization is visible"
						}
					],
					"returns": []
				},
				"setCreationValid": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Controls the rendering of the creation visualization. ",
					"params": [
						{
							"name": "valid",
							"type": "bool",
							"description": "Wheter the visualization should render as valid"
						}
					],
					"returns": []
				},
				"setCreationFreePlacement": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Controls the transform of the visualization. If true the visualization will render using setFreePlacementPosition/setFreePlacementRotation functions.\n\nIf false the visualization will render ontop of the creation.",
					"params": [
						{
							"name": "valid",
							"type": "bool",
							"description": "Wheter the visualization should use free placement"
						}
					],
					"returns": []
				},
				"setCreationFreePlacementPosition": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Set the world position of the visualization. Only works if setFreePlacement is true.",
					"params": [
						{
							"name": "position",
							"type": "vec3",
							"description": "World position of the visualization"
						}
					],
					"returns": []
				},
				"setCreationFreePlacementRotation": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Set the rotation index of the visualization. Only works if setFreePlacement is true.",
					"params": [
						{
							"name": "index",
							"type": "int",
							"description": "Index to rotate the visualization with"
						}
					],
					"returns": []
				},
				"setLiftPosition": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Set the world position of the lift visualization.",
					"params": [
						{
							"name": "position",
							"type": "vec3",
							"description": "World position of the lift visualization"
						}
					],
					"returns": []
				},
				"setLiftLevel": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Set the lift level of the lift visualization.",
					"params": [
						{
							"name": "level",
							"type": "int",
							"description": "The level of the lift"
						}
					],
					"returns": []
				},
				"setLiftVisible": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Controls the visibility of the lift visualization",
					"params": [
						{
							"name": "visible",
							"type": "bool",
							"description": "Whether the lift visualization is visible"
						}
					],
					"returns": []
				},
				"setLiftValid": {
					"args": 1,
					"sandbox": "clientMethod",
					"description": "Controls the rendering of the lift visualization. ",
					"params": [
						{
							"name": "valid",
							"type": "bool",
							"description": "Whether the visualization should render as valid"
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.cell": {
			"constants": {},
			"tabledata": {
				"getNodes": {
					"args": 3,
					"sandbox": "",
					"description": "Returns all nodes of a given type for a cell coordinate as a table.",
					"params": [
						{
							"name": "x",
							"type": "int",
							"description": "X-coordinate"
						},
						{
							"name": "y",
							"type": "int",
							"description": "Y-coordinate"
						},
						{
							"name": "type",
							"type": "string",
							"description": "The node type"
						}
					],
					"returns": [
						{}
					]
				},
				"getInteractablesByName": {
					"args": 3,
					"sandbox": "serverMethod",
					"description": "Returns all [`interactables`]([[sm.interactable]] \"sm.interactable\") with a given name for a cell coordinate.",
					"params": [
						{
							"name": "x",
							"type": "int",
							"description": "The X-coordinate"
						},
						{
							"name": "y",
							"type": "int",
							"description": "The Y-coordinate"
						},
						{
							"name": "name",
							"type": "string",
							"description": "The name of the interactable(s)"
						}
					],
					"returns": [
						{}
					]
				},
				"getInteractablesByUuid": {
					"args": 3,
					"sandbox": "serverMethod",
					"description": "Returns all [`interactables`]([[sm.interactable]] \"sm.interactable\") of a given type for a cell coordinate.",
					"params": [
						{
							"name": "x",
							"type": "int",
							"description": "The X-coordinate"
						},
						{
							"name": "y",
							"type": "int",
							"description": "The Y-coordinate"
						},
						{
							"name": "uuid",
							"type": "uuid",
							"description": "The uuid of the interactable(s)"
						}
					],
					"returns": [
						{}
					]
				}
			},
			"userdata": {}
		},
		"sm.vec3": {
			"constants": {},
			"tabledata": {
				"new": {
					"args": 3,
					"sandbox": "",
					"description": "Creates a new vector.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						},
						{
							"name": "z",
							"type": "number",
							"description": "The Z value."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The created vector."
						}
					]
				},
				"zero": {
					"args": 0,
					"sandbox": "",
					"description": "Creates a new vector with 0 in x, y, x.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The zero vector."
						}
					]
				},
				"one": {
					"args": 0,
					"sandbox": "",
					"description": "Creates a new vector with 1 in x, y, x.",
					"params": [],
					"returns": [
						{
							"type": "vec3",
							"description": "The one vector."
						}
					]
				},
				"getX": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the X value of a vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The X value."
						}
					]
				},
				"setX": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the X value of a vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						}
					],
					"returns": []
				},
				"getY": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the Y value of a vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The Y value."
						}
					]
				},
				"setY": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the Y value of a vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						}
					],
					"returns": []
				},
				"getZ": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the Z value of a vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The Z value."
						}
					]
				},
				"setZ": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the Z value of a vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "z",
							"type": "number",
							"description": "The Z value."
						}
					],
					"returns": []
				},
				"normalize": {
					"args": 1,
					"sandbox": "",
					"description": "Normalizes a vector, ie. converts to a unit vector of length 1.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The normalized vector."
						}
					]
				},
				"dot": {
					"args": 2,
					"sandbox": "",
					"description": "Returns the [dot product](https://en.wikipedia.org/wiki/Dot_product) of a vector.",
					"params": [
						{
							"name": "vector1",
							"type": "vec3",
							"description": "The first vector."
						},
						{
							"name": "vector2",
							"type": "vec3",
							"description": "The second vector."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The dot product."
						}
					]
				},
				"cross": {
					"args": 2,
					"sandbox": "",
					"description": "Returns the [cross product](https://en.wikipedia.org/wiki/Cross_product) of two vectors.",
					"params": [
						{
							"name": "vector1",
							"type": "vec3",
							"description": "The first vector."
						},
						{
							"name": "vector2",
							"type": "vec3",
							"description": "The second vector."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The cross product."
						}
					]
				},
				"length": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the distance of the vector.\n\nIf you want the squared length, using [`length2`]([[sm.vec3.length2]] \"sm.vec3.length2\") is faster than squaring the result of this function.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The length of the vector."
						}
					]
				},
				"length2": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the squared distance of the vector.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The squared length of the vector."
						}
					]
				},
				"lerp": {
					"args": 3,
					"sandbox": "",
					"description": "Performs a [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation) between two vectors.",
					"params": [
						{
							"name": "vector1",
							"type": "vec3",
							"description": "The first vector."
						},
						{
							"name": "vector2",
							"type": "vec3",
							"description": "The second vector."
						},
						{
							"name": "t",
							"type": "number",
							"description": "Interpolation amount between the two inputs."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "out"
						}
					]
				},
				"rotateX": {
					"args": 2,
					"sandbox": "",
					"description": "Rotate a vector around the X axis.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "angle",
							"type": "number",
							"description": "The angle."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The rotated vector."
						}
					]
				},
				"rotateY": {
					"args": 2,
					"sandbox": "",
					"description": "Rotate a vector around the Y axis.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "angle",
							"type": "number",
							"description": "The angle."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The rotated vector."
						}
					]
				},
				"rotateZ": {
					"args": 2,
					"sandbox": "",
					"description": "Rotate a vector around the Z axis.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "angle",
							"type": "number",
							"description": "The angle."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The rotated vector."
						}
					]
				},
				"rotate": {
					"args": 3,
					"sandbox": "",
					"description": "Rotate a vector around an axis.",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						},
						{
							"name": "angle",
							"type": "number",
							"description": "The angle."
						},
						{
							"name": "normal",
							"type": "vec3",
							"description": "The axis to be rotated around."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The rotated vector."
						}
					]
				},
				"getRotation": {
					"args": 2,
					"sandbox": "",
					"description": "Returns a [`quaternion`]([[userdata.quat]] \"userdata.quat\") representing the rotation from one vector to another.\n\nThe quaternion can then be multiplied with any vector to rotate it in the same fashion.\n\nv1 \\= sm.vec3.new(1,0,0)\nv2 \\= sm.vec3.new(0,1,0)\n\ntrans \\= sm.vec3.getRotation(v1, v2)\n\\-- \\`trans\\` now rotates a vector 90 degrees\n\nprint(trans \\* v2)\n\\-- {<Vec3>, x = -1, y = 0, z = 0}",
					"params": [
						{
							"name": "vector1",
							"type": "vec3",
							"description": "The first vector."
						},
						{
							"name": "vector2",
							"type": "vec3",
							"description": "The second vector."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "The transformation."
						}
					]
				},
				"closestAxis": {
					"args": 1,
					"sandbox": "",
					"description": "Finds the closest axis-aligned vector from the given vector",
					"params": [
						{
							"name": "vector",
							"type": "vec3",
							"description": "The vector."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The axis-aligned vector."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.quat": {
			"constants": {},
			"tabledata": {
				"new": {
					"args": 4,
					"sandbox": "",
					"description": "Creates a new quaternion.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						},
						{
							"name": "z",
							"type": "number",
							"description": "The Z value."
						},
						{
							"name": "w",
							"type": "number",
							"description": "The W value."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "The created quaternion."
						}
					]
				},
				"identity": {
					"args": 0,
					"sandbox": "",
					"description": "Creates a new identity quaternion.",
					"params": [],
					"returns": [
						{
							"type": "quat",
							"description": "The created quaternion."
						}
					]
				},
				"getX": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the X value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The X value."
						}
					]
				},
				"setX": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the X value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						},
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						}
					],
					"returns": []
				},
				"getY": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the Y value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The Y value."
						}
					]
				},
				"setY": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the Y value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						}
					],
					"returns": []
				},
				"getZ": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the Z value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The Z value."
						}
					]
				},
				"setZ": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the Z value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						},
						{
							"name": "z",
							"type": "number",
							"description": "The Z value."
						}
					],
					"returns": []
				},
				"getW": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the W value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The W value."
						}
					]
				},
				"setW": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the W value of a quaternion.",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						},
						{
							"name": "w",
							"type": "number",
							"description": "The W value."
						}
					],
					"returns": []
				},
				"round90": {
					"args": 1,
					"sandbox": "",
					"description": "Rounds the quaternion rotation into 90 degree steps",
					"params": [
						{
							"name": "quaternion",
							"type": "quat",
							"description": "The quaternion."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "quaternion\tThe rounded quaternion."
						}
					]
				},
				"lookRotation": {
					"args": 2,
					"sandbox": "",
					"description": "Create a new quaternion from direction vectors",
					"params": [
						{
							"name": "at",
							"type": "vec3",
							"description": "The forward vector."
						},
						{
							"name": "up",
							"type": "vec3",
							"description": "The up vector."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "quaternion\tThe quaternion."
						}
					]
				},
				"slerp": {
					"args": 3,
					"sandbox": "",
					"description": "Performs a spherical linear interpolation between two quaternion.",
					"params": [
						{
							"name": "quaternion1",
							"type": "quat",
							"description": "The first quaternion."
						},
						{
							"name": "quaternion2",
							"type": "quat",
							"description": "The second quaternion."
						},
						{
							"name": "t",
							"type": "number",
							"description": "Interpolation amount between the two inputs."
						}
					],
					"returns": [
						{
							"type": "quat",
							"description": "out"
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.uuid": {
			"constants": {},
			"tabledata": {
				"new": {
					"args": 1,
					"sandbox": "",
					"description": "Generates a uuid.",
					"params": [
						{
							"name": "uuid",
							"type": "string",
							"description": "The string to generate an uuid instance from. If none is provided, generate a random uuid."
						}
					],
					"returns": [
						{
							"type": "uuid",
							"description": "The created uuid."
						}
					]
				},
				"getNil": {
					"args": 0,
					"sandbox": "",
					"description": "Creates a nil uuid {00000000-0000-0000-0000-000000000000}",
					"params": [],
					"returns": [
						{
							"type": "uuid",
							"description": "The nil uuid."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.color": {
			"constants": {},
			"tabledata": {
				"new": {
					"args": 1,
					"sandbox": "",
					"description": "Creates a new color object from a hex value `0xRRBBGGAA`.",
					"params": [
						{
							"name": "hexInt",
							"type": "int",
							"description": "The hex value."
						}
					],
					"returns": [
						{
							"type": "color",
							"description": "The created color."
						}
					]
				},
				"getR": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the red value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The red value."
						}
					]
				},
				"getG": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the green value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The green value."
						}
					]
				},
				"getB": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the blue value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The blue value."
						}
					]
				},
				"getA": {
					"args": 1,
					"sandbox": "",
					"description": "Returns the alpha value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The alpha value."
						}
					]
				},
				"setR": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the red value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						},
						{
							"name": "r",
							"type": "number",
							"description": "The red value."
						}
					],
					"returns": []
				},
				"setG": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the green value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						},
						{
							"name": "g",
							"type": "number",
							"description": "The green value."
						}
					],
					"returns": []
				},
				"setB": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the blue value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						},
						{
							"name": "b",
							"type": "number",
							"description": "The blue value."
						}
					],
					"returns": []
				},
				"setA": {
					"args": 2,
					"sandbox": "",
					"description": "Sets the alpha value of a color.",
					"params": [
						{
							"name": "color",
							"type": "color",
							"description": "The color object."
						},
						{
							"name": "a",
							"type": "number",
							"description": "The alpha value."
						}
					],
					"returns": []
				}
			},
			"userdata": {}
		},
		"sm.util": {
			"constants": {},
			"tabledata": {
				"clamp": {
					"args": 3,
					"sandbox": "",
					"description": "Restricts a value to a given range.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The value."
						},
						{
							"name": "lower",
							"type": "number",
							"description": "The lower limit."
						},
						{
							"name": "upper",
							"type": "number",
							"description": "The upper limit."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The clamped value."
						}
					]
				},
				"lerp": {
					"args": 3,
					"sandbox": "",
					"description": "Linear interpolation between two values. This is known as a lerp.",
					"params": [
						{
							"name": "x0",
							"type": "number",
							"description": "The first value."
						},
						{
							"name": "x1",
							"type": "number",
							"description": "The second value."
						},
						{
							"name": "t",
							"type": "number",
							"description": "The interpolation step."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The interpolated value between two values."
						}
					]
				},
				"bezier2": {
					"args": 4,
					"sandbox": "",
					"description": "Quadratic Bezier interpolation. One dimensional bezier curve.",
					"params": [
						{
							"name": "c0",
							"type": "number",
							"description": "The start value."
						},
						{
							"name": "c1",
							"type": "number",
							"description": "The control point."
						},
						{
							"name": "c2",
							"type": "number",
							"description": "The end value."
						},
						{
							"name": "t",
							"type": "number",
							"description": "The interpolation step."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The interpolated value between two values."
						}
					]
				},
				"bezier3": {
					"args": 5,
					"sandbox": "",
					"description": "Cubic Bezier interpolation. One dimensional bezier curve.",
					"params": [
						{
							"name": "c0",
							"type": "number",
							"description": "The start value."
						},
						{
							"name": "c1",
							"type": "number",
							"description": "The first control point."
						},
						{
							"name": "c2",
							"type": "number",
							"description": "The second control point."
						},
						{
							"name": "c3",
							"type": "number",
							"description": "The end value."
						},
						{
							"name": "t",
							"type": "number",
							"description": "The interpolation step."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The interpolated value between two values."
						}
					]
				},
				"positiveModulo": {
					"args": 2,
					"sandbox": "",
					"description": "Returns the positive remainder after division of x by n.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The number."
						},
						{
							"name": "n",
							"type": "number",
							"description": "The modulo value."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The value."
						}
					]
				},
				"smoothstep": {
					"args": 3,
					"sandbox": "",
					"description": "Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`. This is useful in cases where a threshold function with a smooth transition is desired.",
					"params": [
						{
							"name": "edge0",
							"type": "number",
							"description": "The value of the lower edge of the Hermite function."
						},
						{
							"name": "edge1",
							"type": "number",
							"description": "The value of the upper edge of the Hermite function."
						},
						{
							"name": "x",
							"type": "number",
							"description": "The source value for interpolation."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The value."
						}
					]
				},
				"smootherstep": {
					"args": 3,
					"sandbox": "",
					"description": "An improved version of the [`smoothstep`]([[sm.util.smoothstep]] \"sm.util.smoothstep\") function which has zero 1st and 2nd order derivatives at `x = edge0` and `x = edge1`.",
					"params": [
						{
							"name": "edge0",
							"type": "number",
							"description": "The value of the lower edge of the Hermite function."
						},
						{
							"name": "edge1",
							"type": "number",
							"description": "The value of the upper edge of the Hermite function."
						},
						{
							"name": "x",
							"type": "number",
							"description": "The source value for interpolation."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The value."
						}
					]
				}
			},
			"userdata": {}
		},
		"sm.noise": {
			"constants": {},
			"tabledata": {
				"simplexNoise1d": {
					"args": 1,
					"sandbox": "",
					"description": "A simplex noise 1d function.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The noise value."
						}
					]
				},
				"simplexNoise2d": {
					"args": 2,
					"sandbox": "",
					"description": "A simplex noise 2d function.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The noise value."
						}
					]
				},
				"intNoise2d": {
					"args": 4,
					"sandbox": "",
					"description": "An integer noise 2d function.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						},
						{
							"name": "octaves",
							"type": "int",
							"description": "The octaves."
						},
						{
							"name": "seed",
							"type": "int",
							"description": "The seed."
						}
					],
					"returns": [
						{
							"type": "int",
							"description": "The noise value."
						}
					]
				},
				"floatNoise2d": {
					"args": 3,
					"sandbox": "",
					"description": "A float noise 2d function.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						},
						{
							"name": "seed",
							"type": "int",
							"description": "The seed."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The noise value."
						}
					]
				},
				"octaveNoise2d": {
					"args": 4,
					"sandbox": "",
					"description": "An octave noise 2d function.",
					"params": [
						{
							"name": "x",
							"type": "number",
							"description": "The X value."
						},
						{
							"name": "y",
							"type": "number",
							"description": "The Y value."
						},
						{
							"name": "octaves",
							"type": "int",
							"description": "The octaves."
						},
						{
							"name": "seed",
							"type": "int",
							"description": "The seed."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The noise value."
						}
					]
				},
				"randomRange": {
					"args": 2,
					"sandbox": "",
					"description": "Returns a random number N such that `a <= N <= b`.",
					"params": [
						{
							"name": "a",
							"type": "number",
							"description": "The lower bound."
						},
						{
							"name": "b",
							"type": "number",
							"description": "The upper bound."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The random value."
						}
					]
				},
				"randomNormalDistribution": {
					"args": 2,
					"sandbox": "",
					"description": "Returns a random number according to the [normal random number distribution](https://en.wikipedia.org/wiki/Normal_distribution).\n\nValues near the **mean** are the most likely.\n\nStandard **deviation** affects the dispersion of generated values from the mean.",
					"params": [
						{
							"name": "mean",
							"type": "number",
							"description": "The mean."
						},
						{
							"name": "deviation",
							"type": "number",
							"description": "The deviation."
						}
					],
					"returns": [
						{
							"type": "number",
							"description": "The random number."
						}
					]
				},
				"gunSpread": {
					"args": 2,
					"sandbox": "",
					"description": "Returns a directional vector with a random spread given by a [`normal distribution`]([[sm.noise.randomnormaldistribution]] \"sm.noise.randomnormaldistribution\").",
					"params": [
						{
							"name": "direction",
							"type": "vec3",
							"description": "The direction."
						},
						{
							"name": "spreadAngle",
							"type": "number",
							"description": "The spread angle in degrees."
						}
					],
					"returns": [
						{
							"type": "vec3",
							"description": "The spread direction."
						}
					]
				}
			},
			"userdata": {}
		}
	}
}